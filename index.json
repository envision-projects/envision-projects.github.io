[{"body":"Embedded Systems are combinations of hardware and software that are built for a specific purpose in mind, as opposed to personal computers which are more general use. Common examples include smart watches, home sensor arrays, Bluetooth headphones, even microwaves and refrigerators; they are nearly ubiquitous in modern technology.\nThis course will direct the student through the design and implementation process for creating their own custom embedded system.\nEach certified student will be proficient in\nMicrocontroller programming - an overview of common APIs such as Arduino and VSCode as well as basic programming skills in C++ Sensor integration - an understanding of common sensors, how they operate, and how to use them in a program Communication protocols (I2C/SPI) - proficiency in inter-chip communication for fast information transfer between sensors and microcontrollers Analog and digital data acquisition (ADC/DAC) - an understanding of how microcontrollers process analog signals, including bit depth, sample rate and how these affect data acquisition ","link":"/embedded/","section":"embedded","title":"Embedded Systems Certification"},{"body":" ELECTRICAL DESIGN\nElectrical - Soldering, PCB Design, Schematic Understanding, Eagle and Altium Designer CAD Software, PCB Mill, Reflow Oven, Component Sourcing, Circuit Board Troubleshooting and Repair\nElectrical Design will focus on creating functional circuits and PCBs. Students will gain proficiency in schematic reading and design, PCB layout, soldering, SMD soldering, parts sourcing, and PCB diagnostics. 1st Tier Proficiencies:\nThrough-hole Soldering / SMD Soldering Schematic and PCB Design / Layout PCB Testing and Troubleshooting 2nd Tier Proficiencies:\nReflow work - fixing PCBs Power Conditioning Using Oscilloscopes and Power Supplies ","link":"/electrical/","section":"electrical","title":"Electrical Certification"},{"body":"Craft cert info goes here\n","link":"/craft/","section":"craft","title":"Craft Certification"},{"body":"SolidWorks Software, 3D Printing, Post Processing, Laser Cutting, Enclosures and Assemblies, CNC Machine, Solid CAM, Motor/Servo Control, Finite Element Analysis, woodworking\nMechanical Design and Prototyping will focus on the process through which moving machines are created and built. Beginning with ideation in CAD software, this certification will cover all parts of the process, from idea to product. Much of the material will concentrate on modern fabrication tools.\nEach certified student will be proficient in:\nCAD Software - a working knowledge of 2D and 3D design software including Adobe Illustrator and Solidworks 3D Printing - an understanding of different 3D printing techniques, slicing software, and the functionality of 3D printers in general Laser Cutting - something about laser cutting, probably. Get Started! ","link":"/mechanical/","section":"mechanical","title":"Mechanical Design and Prototyping Certification"},{"body":"Just an example of an additional docs folder.\nSurprised that it doesn't have a left sidebar menu? Worry not; just follow this instructions to enable it.\nTutorials Back to docs ","link":"/tutorials/","section":"tutorials","title":"Tutorials' Docs"},{"body":"Microcontrollers:\n","link":"/electrical/familiarize-yourself/","section":"electrical","title":"Familiarize Yourself "},{"body":"For this project, you will design a robot that walks around using a 4-bar linkage for legs! You will be required to:\nDesign a working chassis to house all electronic components in SolidWorks. Manufacture and/or source all parts needed (nuts, bolts, motors, microcontrollers, etc.). Create a Motion Study in SolidWorks that theoretically proves your design will work as intended. Assemble the robot and write code to make it run. Brief on 4-bar Linkages 4-bar linkages are a very common mechanism used in mechanical engineering that consists of four rods connected by pins. These mechanisms convert rotational motion into a rocking motion which can be very useful in robotic arms, clamping mechanisms, animatronics etc.\nGif Source: mecademie on YouTube\nWhen designing 4-bar linkages engineers play with different rod lengths in order to find an ideal output motion. One can calculate the exact range of motion when given each rod length.\nThe simplest 4-bar linkage can be seen below, called a crank-rocker mechanism. Two of the pin joints are mounted in all directions, unable to move at all. The crank arm is the input rod that controls the entire system and is what's typically driven by a motor. The coupler arm simply connects the input crank to the output rocker arm but is crucial in determining the range of motion of the entire mechanism. The output rocker arm is always longer than or equal to the length of the crank arm.\nImage Source: Wikipedia\nIn this robot may notice that there are actually two crank-rocker mechanisms at work:\nDesign a Chassis You can design this robot with one or two continuous rotation motors. In this tutorial we will be following a robot that has two high torque continuous rotation servo motors.\nWithout dimensions, here is an example of a semi-working chassis:\nThis chassis does not show how to mount the microcontroller or the battery, that will be up to you to add! Design the Links For this project you will need a total of three different linkages of varying lengths as shown:\nThe short orange link connects the top of the blue leg shaft to the chassis. The middle hole on the blue leg connects directly to the servo motor wheel which acts as the crank. Lastly, the link acts as the coupler. Intentionally dimensions were left out since your model will most likely be different and you should play around with the linkage lengths in order to figure out what dimensions work best.\nCreate a Motion Study in SolidWorks Head to: Tutorials -\u0026gt; Motion Study: SolidWorks and walk through the tutorial. You will learn to create camera keyframes, animations, basic motors, physics simulations, and motion analyses. For the purposes of this project, you should at least read through the entire tutorial and try out some of the examples.\n","link":"/mechanical/walking-robot/","section":"mechanical","title":"Walking Robot"},{"body":" The SimpleSynth is a Teensy-based audio synthesizer. We will be building an expansion board for the Teensy, as well as an enclosure for the boards and controls (switches, buttons, potentiometers, etc…) and then programming the synthesizer using the Arduino IDE and the Audio System Design Tool for the Teensy Audio Library. While the final product represented here is fully functional, it is also very expandable, and users are encouraged to explore ways of doing so by adding various effects, controls, displays, etc…\nOur Microcontroller of choice for this project is the Teensy 4.1:\nhttps://www.pjrc.com/store/teensy41.html\n…which we will use with the Teensy Audio Board:\n** https://www.pjrc.com/store/teensy3_audio.html**\n(A small plug for Teensy - the Teensy series of ARM-based microcontrollers is AWESOME and very powerful and easy to use. There is also a great community of Teensy users, led by the main developer, PJRC: https://www.pjrc.com/ There is also an incredibly useful and helpful forum for troubleshooting and general problem solving help: https://forum.pjrc.com/ ) The final synthesizer will have the following:\nFull octave ( C - C ) keyboard 3 oscillators of variable waveshapes Digital filter with parameter controls Digital delay with parameter controls In order to build the synthesizer,\nWe will create and design our circuit board in Altium Designer We will design our enclosure using Adobe Illustrator and Makercase.com We will source and purchase parts from Digikey.com We will program the synthesizer using the Teesny Audio System Design Tool, the Teensy Audio Library, and Arduino IDE PART 1: PCB/Schematic Creation\nCreate a new project in Altium and call it SimpleSynth Add a new schematic document to the project, followed by a new PCB document, both named SimpleSynth The primary component of our circuit board will be the Teensy 4.1, so we need to either create our own schematic symbol and footprint, or download one from SnapEDA.com: Teensy4.1 Design Files ( I created my own schematic and footprint, so if you download them, yours may look different ) The next component we’ll need is the Texas Instruments CD74HC4067M, which is a 16-channel Multiplexer/demultiplexer. ( The MUX/DeMUX chip is what we’ll use for the extra digital inputs we need for the 12 keys on the keyboard ) Unlike the Teensy, we can find this chip by using the Manufacturer Part Search in Altium. Just paste the part number in the search dialog and choose the first part that comes up. ( verify that this is the SMD version of the chip and not the through hole version ) Now we need an LED and a resistor which will serve as our power indicator. Use the Manufacturer Part Search to find “LED 0805” and “resistor 0805” and place both components. Change the resistor’s comment to “560R” (560 Ohms) Add a GND port to all GND pins and pin 2 of the LED. Connect a Power Port to VCC and 3.3v pins, as well as pin 1 of the resistor. Also connect it to the E pin of the MUX chip. Connect Teensy pins D36, D35, D34, D33 to S0, S1, S2, S3 respectively on the MUX. You should now have approximately this:\nNow we need to add the switches that we’ll use for our keys. Use the MPS to find “SW-SPST” and place 13 of them. Copy and paste the resistor. Change the value to 10k and then paste 12 more. Connect one to each switch. Connect the open end of the switches to another 3.3v power port, and connect the open pin of the resistors to a GND port. Now we should annotate our schematic, meaning, assign every component its own unique designator, which we will need to refer to in our PCB. To do this, press t a a. You will see this dialogue:\nPress \u0026quot;Update Changes List\u0026quot;, then press \u0026quot;OK\u0026quot;, Press \u0026quot;Accept Changes.\u0026quot; When the net dialogue opens, press \u0026quot;Execute Changes.\u0026quot; Once finished, you can close those the annotation windows.\nNow we need to create our Nets: the Nets will connect the switches to the MUX inputs, and we need one per note on our keyboard. Connect wires to the conjunction of the switches and resistors:\nand then add the same nets to the MUX:\nYou should now have something that looks like this:\nAnd Now we're done with the schematic. This is a very simple schematic; we don't need to add a lot of components because the Teensy handles all of our power conditioning, USB connection, and clocking. All we've really done is enable easy connections between our keys, the multiplexer, and the Teensy. Next we create the PCB layout.\nPART 2: PCB Creation\nThis is the first part of the project where you get to be creative. I won't go into step-by-step detail describing this part of the project once we get the parts into the PCB, but rather talk about some best practices and general considerations. The rest will be up to the user to decide the aesthetics of their board.\nWhile in the schematic document, press d, then u. (For Design, Update PCB Document)\nIn the pop-up dialogue, validate the changes, then execute the changes. Close the windows.\nNow go to the PCB document. If you properly created all your nets and schematic symbols, you should now see all of your components laid out in a row next to a blank slate. It should look something like this:\nWe now need to determine what our PCB will look like. Before we even decide how large our board will be, we need to get a general idea of what our component placement will be. Drag the components into the black area of the page to place them on the PCB area. Keep in mind that the switches should be close to their associated resistors. You also want to place the MUX chip between the switches and the Teensy. Something like this:\nNow connect all the nets with wires. I typically use 9mil traces for signals, and 15 - 21mil traces for power connections.\nBefore we determine our board size, we want to make sure everything will (at least for now) fit. Remember that the audio shield will be on the Teensy, and that it is significantly wider than its parent board. So that we get an idea of its size, I have created an outline for it on the Top Overlay layer, using the line tool. The Audio board is approximately 3.9mm x 3.9mm and isn't seated in the middle of the Teensy, but rather is a bit off center:\nNow we know the general size of our board (but keep in mind that we'll be adding more components as we go so leave some space). Create a polygon pour around your components. A simple rectangle is fine. Add the polygon to the GND net.\nOn layer Mechanical 15, create a box around your polygon pour using the line tool.\nWhile still on layer Mechanical 15, press e, s, y, then d, s, s (Edit, Select, All on Layer, Design, Board Shape, Define Board Shape).\nNext we want to create mounting holes for our board. This isn't absolutely necessary, but it's a good habit to get into (trust me). Create a via that is 4mm with a 3mm hole. Copy and paste this so there's one in each corner. We should now have something like this:\n","link":"/embedded/simplesynth-project/","section":"embedded","title":"SimpleSynth Project"},{"body":"Generic Online Tutorial\nHow To Solder: A Complete Beginners Guide - Makerspaces.com\nEnvision Soldering Tutorial\nEnvision Resource Site - Soldering Stations (google.com)\n","link":"/tutorials/soldering/","section":"tutorials","title":"Soldering"},{"body":"Tutorial - A Complete Design Walkthrough with Altium Designer | Altium Designer 22 User Manual | Documentation\n","link":"/tutorials/altium-tutorials-1/","section":"tutorials","title":"Altium Tutorials"},{"body":"Read\nhttps://docs.kicad.org/6.0/en/getting_started_in_kicad/getting_started_in_kicad.html\nWatch\nCreating Circuit Boards with KiCad 6\nhttps://www.youtube.com/watch?v=5Be7XOMmPQE\n","link":"/tutorials/kicad-tutorial/","section":"tutorials","title":"KiCad Tutorials"},{"body":" 1.1 Introduction\nPhysical circuits on a board are first built on paper in the form of a schematic diagram. Circuit design typically begins with a schematic, where components are chosen, nets are created, and the flow of signals determined. The PCB is then created by using the schematic as its primary reference. Building the PCB from the schematic and working with the two in tandem not only simplifies PCB layout, but also allows for better error checking, component selection, and overall workflow.\n1.2 Electrical Components\nA component is any part or piece that is attached to a circuit board. This includes:\nResistors Capacitors Light Emitting Diode (LED) Transistors Inductors Integrated Circuit (IC) Circuit Breaker Fuse Switch Transformer Electrical Wires \u0026amp; Power Cables Battery Relay Motor ( https://www.dfliq.net/blog/the-basics-of-electrical-components/ )\n1.3 Schematic Symbols\n1.4 Basic Schematic Concepts\nWhen you create a schematic, you are developing all of the nets, or connections, that will eventually exist on your circuit board. Every single pin on every single component will be connected to another pin, a ground plane, or a copper island ( a visible piece of copper on the top of the board that is not associated with a net ), and the schematic determines where all of those connections are.\n","link":"/electrical/schematic-design/","section":"electrical","title":"Schematic Design"},{"body":" EnVision Maker Studio\nDescription: Build a rover vehicle that drives straight until it encounters an object that it must detect and drive away from (Like a small Roomba!). This project can be made using a microcontroller of your choice, in this example I will use an Arduino Uno combined with an Adafruit motor shield. This document will also be covering the basics of ultrasonic sensors as it is used for detecting objects within a specified distance. Components Used: Ultrasonic Sensor (HC-SR04) 4 x DC Gearbox Motors Arduino Uno Adafruit Motor Shield v2 SG90 Servo Motor 9 Volt Battery Jump Wires Process: Design Chassis in Solidworks to be 3D printed\nCreate assembly complete with housing for all electronic components Learn how to drive the motors and use the sweeping ultrasonic function\nAssemble and test robot\nFine-tune motors to drive in a straight line Typical Final Assembly of Robot (just to get an idea of where you’re headed):\nDesigning the chassis in SolidWorks: Depending on the type of drive system you want (2-wheel or 4-wheel drive), create a new SolidWorks part that will house your motor, micro servo, Arduino Uno, Adafruit Motor Shield, and battery pack.\nHere are some examples that are NOT finished but may give you some ideas:\n2-wheel continuous servo chassis (basic)\n2-wheel larger chassis with battery storage\nArduino and Adafruit Motor Shield: Refer to the official website for more detailed information\nEnsure you have the Arduino IDE installed In the IDE make sure you also install the library (Link to V2 library) This is everything you will need to include in this project at the top of the Sketch:\n#include \u0026lt;Adafruit_MotorShield.h\u0026gt; #include \u0026#34;utility/Adafruit_MS_PWMServoDriver.h\u0026#34; #include \u0026lt;Servo.h\u0026gt; Driving the Motors For this project, you have to learn to drive servo motors and/or dc motors. Luckily the Adafruit Motor shield makes it very simple to code because of the installed Arduino library. The below diagram shows the locations where you will connect your dc motors.\nThe direction of the motors will depend on the orientation of the wires connected to the motor shield.\nIf you are using continuous rotation servo motors for this project be aware that the motor shield only has slots for two servos in the top left. The code below shows how to initialize each motor you're using including the ultrasonic sweep servo. You can place this code block before the void setup.\nAdafruit_MotorShield AFMS = Adafruit_MotorShield(); //Initializes Motor Shield Adafruit_DCMotor *RFrontMotor = AFMS.getMotor(4); //Each number corresponds to Motor Shield Adafruit_DCMotor *RBackMotor = AFMS.getMotor(3); //refer to diagram above Adafruit_DCMotor *LBackMotor = AFMS.getMotor(2); Adafruit_DCMotor *LFrontMotor = AFMS.getMotor(1); Servo sweepServo; In the setup block, you will want to set the default speed of the motors and attach the servo to a pin (9 or 10). The 'run' function described below is also how you will drive the dc motors (RELEASE, FORWARD, and BACKWARD). Servo 1 corresponds to pin value 9 and Servo 2 corresponds to pin value 10.\nvoid setup() { AFMS.begin(); RFMotor-\u0026gt;setSpeed(motorSpeed); //Set motor speed value (70 to 90 should work) LFMotor-\u0026gt;setSpeed(motorSpeed); RBMotor-\u0026gt;setSpeed(motorSpeed); LBMotor-\u0026gt;setSpeed(motorSpeed); RFMotor-\u0026gt;run(RELEASE); //Release all motors before void loop LFMotor-\u0026gt;run(RELEASE); RBMotor-\u0026gt;run(RELEASE); LBMotor-\u0026gt;run(RELEASE); sweepServo.attach(10); // Connect servo motor to pin 10 (Servo 2) } Ultrasonic Sensor Ultrasonic sensors emit sound waves at a very high frequency that humans cannot hear. These sound waves bounce off of objects and return to the sensor where a distance can be calculated based on the time it took the sound wave to return to the sensor.\nFor a bit more information about ultrasonic sensors and how to implement them with Arduino check out this article.\nSweep Function The ultimate goal of the ultrasonic sensor sweep function is to first detect an object in front of the robot and then determine the best direction for the robot to proceed forward in. Thus when an object is detected within the safe space of the robot:\nSweep Function Test Use this section to test out how to code the ultrasonic sensor and implement it with the Arduino and micro servo. The annotated code below shows which pins to connect to on the board (ensure the VCC pin is connected to 5V) as well as how each block works.\n// Blake Iwaisako // 11 August 2022 #include \u0026lt;Servo.h\u0026gt; Servo sweepServo; const int trig = 12; // Trig pin const int echo = 13; // Echo pin int pos = 0; // Initial position integer long dur; // Initialize long variables: duration of ultrasonic pulse long tocm; // microseconds to cm variable bool returningToZero; // Create boolean for returning to zero void setup() { Serial.begin(9600); // Connect to serial monitor pinMode(echo, INPUT); // echo pin corresponds to \u0026#34;echo\u0026#34; on Ultrasonic Sensor pinMode(trig, OUTPUT); // \u0026#34;trig\u0026#34; pin on sensor sweepServo.attach(9); sweepServo.write(0); } bool objectDetected(long tocm) // Create boolean to detect object { if (tocm \u0026lt; 20) // Any objects within 20 cm will be noticed { return true; } else { return false; } } void loop() { digitalWrite(trig, LOW); // Momentarily turns off trigger delayMicroseconds(2); digitalWrite(trig, HIGH); // Turn on trigger to send a pulse for delayMicroseconds(10); // 10 microseconds digitalWrite(trig, LOW); // Turn off trigger dur = pulseIn(echo, HIGH); // Records ultrasonic pulse via the echo pin tocm = microsecondsToCentimeters(dur); // Determine in cm distance of object based on pulse duration if (objectDetected(tocm)) // If variable tocm is within 20 cm threshold { Serial.print(\u0026#34;Object detected. Object\u0026#39;s distance: \u0026#34;); // This block prints out the distance of the detected object Serial.print(tocm); // and the angle of the servo in which the object was found Serial.print(\u0026#34;. Servo\u0026#39;s angle: \u0026#34;); // this stops the servo from sweeping as long as the object is seen Serial.println(pos); } else { if (pos \u0026lt; 180 \u0026amp;\u0026amp; returningToZero == false) // This block rotates the servo in intervals of 10cm back and forth { sweepServo.write(pos); pos += 10; Serial.print(\u0026#34;Searching for object. Servo\u0026#39;s angle: \u0026#34;); Serial.println(pos); if (pos == 180) // When the servo reaches the maximum angle 180 it returns to zero returningToZero = true; } else if (returningToZero == true) { pos -= 10; Serial.print(\u0026#34;Searching for object. Servo\u0026#39;s angle: \u0026#34;); Serial.println(pos); sweepServo.write(pos); if (pos == 0) // When the servo reaches minimum angle it returns to zero returningToZero = false; } } delay(200); } long microsecondsToCentimeters(long microseconds) // Converter for microseconds to cm { return microseconds / 29.155 / 2; } Putting it All Together Once the robot is assembled, the rest of the project mainly consists of writing code and troubleshooting.\nHere is a complete annotated version of the code for you to refer to:\n// Blake Iwaisako // 1 August 2022 #include \u0026lt;Wire.h\u0026gt; #include \u0026lt;Adafruit_MotorShield.h\u0026gt; #include \u0026#34;utility/Adafruit_MS_PWMServoDriver.h\u0026#34; #include \u0026lt;Servo.h\u0026gt; Adafruit_MotorShield AFMS = Adafruit_MotorShield(); Adafruit_DCMotor *RFMotor = AFMS.getMotor(4); Adafruit_DCMotor *LFMotor = AFMS.getMotor(1); Adafruit_DCMotor *RBMotor = AFMS.getMotor(3); Adafruit_DCMotor *LBMotor = AFMS.getMotor(2); Servo sweepServo; byte trig = 2; //trigger pin byte echo = 13; //echo pin byte maxDist = 150; //maximum distance for sensing (outside of this distance objects are ignored) byte stopDist = 50; //closest distance to an object allowable float timeOut = 2*(maxDist+10)/100/134*1000000; //Max time to wait for return signal byte motorSpeed = 70; //Max motor speed (do not exceed 70) byte motorOffset = 10; //Change to account for one motor being to powerful int turnSpeed = 60; //Amount to add to motor during turns void setup() { AFMS.begin(); RFMotor-\u0026gt;setSpeed(motorSpeed); //Set motor speed LFMotor-\u0026gt;setSpeed(motorSpeed); RBMotor-\u0026gt;setSpeed(motorSpeed); LBMotor-\u0026gt;setSpeed(motorSpeed); RFMotor-\u0026gt;run(RELEASE); //Release all motors before loop LFMotor-\u0026gt;run(RELEASE); RBMotor-\u0026gt;run(RELEASE); LBMotor-\u0026gt;run(RELEASE); pinMode(trig, OUTPUT); pinMode(echo, INPUT); sweepServo.attach(10); } void loop() { sweepServo.write(90); //Set servo to look straight ahead delay(500); int distance = getDistance(); //check for objects directly ahead if(distance \u0026gt;= stopDist) //if there are no objects within the stopping distance, move forward { moveForward(); } while(distance \u0026gt;= stopDist) //keep checking the object distance until it is within the minimum stopping distance { distance = getDistance(); delay(250); } stopMove(); //stop the motors int turnDir = checkDirection(); //check the left and right object distances and get the turning instruction Serial.print(turnDir); switch (turnDir) //turn left, turn around or turn right depending on the instruction { case 0: //turn left turnLeft(1000); break; case 1: turnLeft(2000); //turn around break; case 2: turnRight(1000); //turn right break; } } //create functions for movement and scanning void accelerate() //function to accelerate motors from 0 to full speed { for (int i=0; i\u0026lt;motorSpeed; i++) { RFMotor-\u0026gt;setSpeed(i); LFMotor-\u0026gt;setSpeed(i); RBMotor-\u0026gt;setSpeed(i); LBMotor-\u0026gt;setSpeed(i); delay(10); } } void decelerate() //function to decelerate motors from full speed to zero { for(int i=motorSpeed; i!=0; i--) { RFMotor-\u0026gt;setSpeed(i); LFMotor-\u0026gt;setSpeed(i); RBMotor-\u0026gt;setSpeed(i); LBMotor-\u0026gt;setSpeed(i); delay(10); } } void moveForward() //set all motors to run FORWARD { RFMotor-\u0026gt;run(FORWARD); LFMotor-\u0026gt;run(FORWARD); RBMotor-\u0026gt;run(FORWARD); LBMotor-\u0026gt;run(FORWARD); } void stopMove() //set all motors to stop { RFMotor-\u0026gt;run(RELEASE); LFMotor-\u0026gt;run(RELEASE); RBMotor-\u0026gt;run(RELEASE); LBMotor-\u0026gt;run(RELEASE); } void turnLeft(int duration) //set motors to turn left for a certain duration variable { RFMotor-\u0026gt;setSpeed(motorSpeed+turnSpeed); //set motors to turning speed LFMotor-\u0026gt;setSpeed(motorSpeed+turnSpeed); RBMotor-\u0026gt;setSpeed(motorSpeed+turnSpeed); LBMotor-\u0026gt;setSpeed(motorSpeed+turnSpeed); RFMotor-\u0026gt;run(FORWARD); RBMotor-\u0026gt;run(FORWARD); LFMotor-\u0026gt;run(BACKWARD); LBMotor-\u0026gt;run(BACKWARD); delay(duration); RFMotor-\u0026gt;setSpeed(motorSpeed); //bring back to motor speed LFMotor-\u0026gt;setSpeed(motorSpeed); RBMotor-\u0026gt;setSpeed(motorSpeed); LBMotor-\u0026gt;setSpeed(motorSpeed); RFMotor-\u0026gt;run(RELEASE); LFMotor-\u0026gt;run(RELEASE); RBMotor-\u0026gt;run(RELEASE); LBMotor-\u0026gt;run(RELEASE); } void turnRight(int duration) { RFMotor-\u0026gt;setSpeed(motorSpeed+turnSpeed); LFMotor-\u0026gt;setSpeed(motorSpeed+turnSpeed); RBMotor-\u0026gt;setSpeed(motorSpeed+turnSpeed); LBMotor-\u0026gt;setSpeed(motorSpeed+turnSpeed); RFMotor-\u0026gt;run(BACKWARD); RBMotor-\u0026gt;run(BACKWARD); LFMotor-\u0026gt;run(FORWARD); LBMotor-\u0026gt;run(FORWARD); delay(duration); RFMotor-\u0026gt;setSpeed(motorSpeed); LFMotor-\u0026gt;setSpeed(motorSpeed); RBMotor-\u0026gt;setSpeed(motorSpeed); LBMotor-\u0026gt;setSpeed(motorSpeed); RFMotor-\u0026gt;run(RELEASE); LFMotor-\u0026gt;run(RELEASE); RBMotor-\u0026gt;run(RELEASE); LBMotor-\u0026gt;run(RELEASE); } int getDistance() // use snesor to measure distance to an object { unsigned long pulseTime; // variable stores pulse travel time int distance; // create a variable to store the calculated distance digitalWrite(trig, HIGH); // generate a 10 microsecond pulse delayMicroseconds(10); digitalWrite(trig, LOW); pulseTime = pulseIn(echo, HIGH, timeOut); // measure time for pulse to return distance = (float)pulseTime * 340 / 2 / 10000; // calculate the object distance on the pulse time return distance; } int checkDirection() // check the left and right directions and decide which way to turn { int distances [2] = {0,0}; // Left and Right distances int turnDir = 1; // direction to turn, 0 Left, 1 Reverse, 2 Right sweepServo.write(180); // turn servo to look Left delay(500); distances [0] = getDistance(); // get the left object distance sweepServo.write(0); // turn servo to look right delay(1000); distances [1] = getDistance(); // get the right object distance if (distances[0] \u0026gt;= 200 \u0026amp;\u0026amp; distances[1] \u0026gt;= 200) // if both directions are clear, turn left turnDir = 0; else if (distances[0] \u0026lt;= stopDist \u0026amp;\u0026amp; distances[1]\u0026lt;=stopDist) // if both directions are blocked, turn around turnDir = 1; else if (distances[0] \u0026gt;= distances[1]) // if left has more space, turn left turnDir = 0; else if (distances[0]\u0026lt;distances[1]) // if right has more space, turn right turnDir = 2; return turnDir; } ","link":"/mechanical/obstacle-avoidance-robot/","section":"mechanical","title":"Obstacle Avoidance Robot"},{"body":" Finite Element Analysis: SolidWorks\n1.1 Quick Introduction: Finite Element Analysis (FEA) is a powerful tool used by engineers to predict how parts and assemblies react to forces: heat, fluid flow, vibration, etc. Computer software such as SolidWorks, FEMAP, ANSYS, and Matlab use numerical analysis to create a general 3D mesh on the surface of the product and calculate stresses based on user-defined materials and forces. Note: Solidworks is not the most precise FEA software to use for engineering purposes, however, it is still accurate and is simple to use. Solidworks comes with a Simulation Advisor which is a helpful tool that walks you through the process. 1.2 Definitions and The Process: Definitions:\nFinite Elements: Discrete amount of shapes used to calculate the deformation of a part. They are connected together at nodes and are typically triangle shaped in SolidWorks.\nMesh: The culmination of all connected finite elements of a part perfectly dispered over the surface area of the part. A good mesh can determine the accuracy of your FEA. Von Mises Stress: Used to predict yielding from external stresses. Typically represented by red colors in FEA, yielding stress can occur at several different locations on a part depending on the load magnitude, direction, and location. The process for FEA goes as follows;\nDefine the reason for the study. You could possibly be concerned with:\nExcessive compression/expansion/deformation Temperatures Loading cycles Define the material being used\nCreate fixed geometries at certain locations\nApply loads at certain locations\nGenerate a mesh to your liking\nRun study\n2.1 Creating a Static Study in SolidWorks The rest of this tutorial will be explained using the part shown below:\nStart by going to the “Simulation” tab at the top of the screen and clicking “New Study”\nIn the Study, menu ensure that you check the Static box under General Simulation and click the green checkmark. 2.2 Applying Materials After you have made a new Study, click on Apply Material at the top of the screen. For this tutorial. we will be using 1023 Carbon Steel. Be aware that most materials you will ever need to analyze will be in this material library, however, you can add your own material be clicking the “Add…” button. When you’re done click “Apply”, this may slightly change the appearance of the material. You can confirm this by checking the features menu on the right side of the screen\n2.3 Creating Fixed Geometries Fixed Geometries can be points, edges, or faces on a part that will not move in a specified direction. In order to run a FEA you need to have at lease one point of fixed geometry. To do this click on the “Fixtures Advisor” in the top bar and then select “Fixed Geometry”. In this instance, we will create a fixed geometry at the faces shown below, note that fixed geometries are denoted by green arrows in SolidWorks.\n2.4 Applying External Forces External Forces can also be applied to points, edges, and faces on a part. Do this by going to the top bar and selecting “External Loads Advisor” and then clicking on “Force”.\nIn this instance, we will apply loads at the two faces shown below (Solidworks automatically points forces in the direction normal to the face of the part).\nTo change the direction of the force being applied, click the “Selected Direction” bubble and then select an axis or edge to bind it to. In this case, it will be in the vertical direction (Y-axis) so I clicked on a nearby edge that was also in the vertical direction. Solidworks also defaults to 1N of force but in this study the part will be under 500 N. (Proceed by clicking the green check mark)\n2.5 Generating a Mesh Solidworks automatically creates a mesh before a Static study is run. However you may want to view and change the resolution of this mesh in order to generate more accurate results with your study. Do this by going to “Run This Study” and clicking on “Create Mesh”.\nThis opens up a window that gives you options on how you want to create your mesh. Mesh Density changes the size of individual triangles depending on how Coarse or Fine you want your elements to be. In this case, we want the finest possible mesh. Mesh Parameters, when checked, allows you to manually input the maximum and minimum element sizes and gives you options for mesh curvatures. In this case we will just be using the “Standard mesh” option. Clicking the green check mark will tell Solidworks to create the modified mesh based on our new settings and parameters. The resulting mesh should look like this:\n2.6 Running the Study and Post Analysis The final step in the process is to run the study by clicking “Run This Study” in the top bar. Allow Solidworks some time to generate the results. Your part should now be visually deformed and new results should pop up in the feature menu. Solidworks automatically gives results for vonMises Stress, Displacement, and Strain. By right clicking on any of the results and clicking “Show”, Solidworks adds color to your part and highlights important areas of change. (This can also be done with a double-click)\nNote: The top left corner of the viewing space shows a “Deformation scale” number. This value is multiplied by the true deformation amount so that it is easier to see a difference in the model. Another Note: According to the von Mises stress chart here, this part has a Yield Strength of 2.827e+08 [N/m^2] and it looks like no sections of the part reach this limit (indicated in red) so, most likely, no yielding will occur under a load of 500 N based on this simple analysis.\nDeformation Scaling\nChanging the scale of deformation is simple. Right click wanted result and go to “Edit Definition”. In the Plot menu, head to the “Deformed shape” section, click “User Defined”, and input a deformation scale number below\nCreating a Deformation Animation\nSometimes it may be useful to see how your part will deform using a moving picture. To create an animation, right click on “Stress1” under “Results” and click on “Animate”.\nThis automatically creates an animation with a default of 5 frames. To make the animation smoother, stop the playback and type in a larger amount like 30. This will take longer to calculate but you will have a much smoother result.\n","link":"/tutorials/finite-element-analysis-solidworks/","section":"tutorials","title":"Finite Element Analysis: SolidWorks"},{"body":" PCB Layout:\n1.1 Introduction:\nPCB layout is a necessary part of electronics development. While breadboards and perfboards are fine for prototyping, fabrication and manufacturing for a production run require a fully functional and professional circuit board. There are several options regarding circuit design tools, but we will focus on three common ones: Eagle, KiCAD and Altium. While there are substantial differences between these programs, there are also many topics and practices that are ubiquitous across platforms. 1.2 Key Terms:\nTrace/Track - the wires that connect components on a circuit board\nTraces connecting through-hole components on a PCB\nVia - holes of various sizes that connect layers on a circuit board\nVias are shown with net and layer labels\nPolygon/Pour - an area of various shape and size made of copper, usually used as a ground plane\nThe above image shows a bottom layer polygon pour that serves as the ground plane\nIC - integrated circuit, or a chip\nThrough-hole - components whose legs go all the way through the pcb and are typically soldered by hand. This is as opposed to\nSurface-mount - components that are soldered to the top (or bottom) of the circuit board and do not traverse any layers.\nLayer - These make up the PCB “stack”. PCBs can be 1 to almost 100 layers, but are typically 2 to 8, in multiples of 2. A 2-layer board will have tracks and polygons on the top and bottom layers.\nThe typical layers are:\nSubstrate Layer - The substrate layer of any PCB is usually made from fiberglass, which gives the board its rigid form. Generally speaking, the majority of boards will have this material for their substrate, with the exception of flexible PCBs, which are built on flexible plastic such as Kapton. Substrate PCB layers can also be made with other materials such as epoxies, however they lack the durability that FR4 (found in fiberglass) provides for a high quality board. Copper Layer - Next is a thin layer of copper foil which is laminated to the board using heat. When we are speaking of different layered PCBs, we are referring to how many copper layers they consist of. If you are creating a single-sided PCB the circuit board has one layer of conducting material on one side of the board and the other side is used for incorporating different electronic components. Whereas double-sided PCBs can mount the conductive copper and components on both sides of the board, as opposed to just the one. These double-sided boards allow for closer routing traces as they can alternate between the top and bottom layers using vias. This can be very useful in many electronic products as the circuits on one side of the board can be connected to the other with the help of holes drilled into it. The thickness of the copper layer on your PCB will depend on the power the PCB needs to withstand. PCBs that need to handle very high power throughout may have a thicker copper layer than those that do not.\nSoldermask layer - Once the copper layer has been applied the soldermask layer is placed on top. This gives the PCB its green color and is used to insulate the copper layer to avoid any contact with any other metal or elements of the board that could disrupt the copper traces. This layer is also important for themanufacturing processwhere the components are soldered onto the board, as it helps the user to solder to the correct places.\nSilkscreen layer - The silkscreen is mainly for the purpose of us humans to help us better understand the board and the functionality of different pins or LEDs, by adding letters, numbers and symbols to the board.\nNet - a collection of pads and tracks that are all connected. No two different nets can be connected.\nHere every color represents a different net\n","link":"/electrical/pcb-layout/","section":"electrical","title":"PCB Layout"},{"body":" Solidworks Motion Study\nEnVision Maker Studio\n1.1 Introduction: Motion studies are graphical simulations of motion for assembly models. You can use Solidworks mates in an assembly to restrict the motion of components in an assembly when you model motion. Motion studies in Solidworks do not change the properties of an assembly model. Instead, if changes are made to the assembly after the creation of the motion study, the software will automatically update the study and reveal any possible conflicts. 1.2 MotionManager: The MotionManager is where you can find all of the core Solidworks tools used for motion analysis: Animation, Basic Motion, and Motion Analysis. This toolbar is by default found at the bottom of the screen, however, if you do not see anything there you may have to enable the add-in in the settings. To do this go to the top of the screen and click on the settings icon and click “Add-ins” from the pull down menu.\nFrom the “Add-ins” menu ensure that “SOLIDWORKS Motion” and “SOLIDWORKS Simulation” are checked before clicking on “OK”.\nAnimation 2.1 Animation Wizard: The Animation Wizard is a quick and easy way to create simple animations of the current assembly. This does not include the movement of parts defined by mates, rather it generates a simple rotation of the entire assembly based on the current camera position.\nIn the first pop-up window select “Rotate Model” and click Next.\nThe second pop-up window will ask you which direction to rate in, how many rotations, and which original axis you would like to rotate about (typically choose Y-axis).\nThe last pop-up menu will ask you when to begin the rotation and how long the rotation will last.\nThe Animation Wizard then generates camera keyframes marked as diamonds in the MotionManager. Before starting the animation, ensure the grey bar is at the “0 sec” mark. Clicking the play button will start the animation.\n2.2 More on Camera Keyframes: Instead of using the Animation Wizard to make keyframes, we can make our own camera keyframes based on our views in the Solidworks assembly window. First find a view in your Assembly window that you want to begin your animation on. Next locate and right-click on the first keyframe next to “Orientation and Camera Views”. Click on “Replace Key”, this changes the first camera view of the animation to be yor preffered starting view. Until you replace this key again, everytime you start the animation from the beginning it will return to this camera view. Bounce Animation: The easiest way to make camera keyframes is by click-holding onto the first keyframe and dragging it along the time line. This makes a copy of the original camera view but that can be changed by clicking “Replace Key”. First create two copies of the first keyframe and place them along the timeline like so: To create the Bounce animation, move the grey bar to be right on top of the middle keyframe. Next move the assembly to a second position that is different from the first. Finally right click on the middle keyframe and select “Replace Key”. Note: this process can be done with any keyframe you create on the camera timeline.\nThis will create a Bounce animation where the camera moves from Position 1 to Position 2 and then back to Position 1. You can also move around the keyframes to change the speed of the Bounce Animation to how you see fit.\n2.3 Motors: Motors can be used to manipulate a component for a certain amount of time as defined by a mate. In this tutorial you will animate a rotation along an axis but be aware that you can also create a linear oscilation along an edge/axis as well. Note: Create a new motion study quickly by right clicking your current “Motion Study” tab at the bottom of the screen and selecting “Create New Motion Study”\nTo create a Rotary Motor, first click on a circular edge to establish what direction and part that you want to move. The assembly mates will update based on the properties of the motor. Ensure that the motor you create has a red arrow indicating the direction of the motor which can be changed. The motion box gives you many options to control the motor including distance, oscillation, segments, etc. For this specific example, I will be using the Constant Speed option which will rotate the motor in one direction at 25 RPM. Clicking the graph at the bottom of the box allows you to more closely analyze the motion.\nAfter clicking the green checkmark, you will see a new Motion Study element created on top of all the model features. To see the motor move click the play button and allow Motion Study to calculate the frames. Note: You can recalculate frames whenever in motion study by clicking the Calculator Icon:\nAnimation Framerate Solidworks automatically sets the framerate of the animations to 8 FPS which creates a rather choppy viewing experience. Change this to a higher number in the animation settings menu Basic Motion Basic Motion is different from Animation as it takes into account the mass, inertia, gravity, and contacts to calculate motion more accurately. Animation simply uses interpolation provided by keyframes whereas Basic Motion is capable of creating more complex real-world simulations. Change to “Basic Motion” in the Motion Manger bar at the bottom of the screen. 3.1 Gravity: Gravity is a key tool to simulating motion in an assembly. Go to the right side of the Motion Manager bar and click on the falling apple symbol. Next, you have the option to choose the direction and magnitude of gravity in your assembly either based on a chosen edge/axis or one of the global axes. In this example, we will choose the global Y-axis and ensure the green arrow is pointed down.\n3.2 Contacts: Defining contact points/surfaces in a Motion Study is crucial to simulating real-world interactions. In Basic Motion, this works well with smooth surfaces that do not have many complicated rough edges. This button is just left of the gravity button.\nNote: You can create contact groups that simulate interactions between different sets of objects. In this example, however, we will only be using one set of contacts. Clicking on parts will highlight the entire surface and create contacts. Clicking on the Calculate button will run the simulation (Be sure to change the framerate to smooth out the animation)\n","link":"/tutorials/solidworks-motion-study/","section":"tutorials","title":"Motion Study: SolidWorks"},{"body":"test CMS\n","link":"/electrical/wipers/","section":"electrical","title":"wipers"},{"body":"Test netlifyCMS\nIn richtext, BOLD\nplain\n","link":"/electrical/pcb-design-with-kicad/","section":"electrical","title":"Pcb Design with KiCAD"},{"body":"Click me!\n","link":"/mechanical/3d-printing/","section":"mechanical","title":"3D Printing"},{"body":"About Omni Car Project By: MingWei Yeoh\nIt's a tank driven car with omni wheels for some sick drifting without the fear of shredding the floor! Combined with a responsive FLYSKY Drone Transmitter, this makes for a fun project!\nChallenges CAD The main gripe with the included motors in the kit is that they are a little slow. Thus we will be making a custom 1:2 speed gearbox with OnShape in order to speed up the drive wheels!\nAnswer Key Onshape Files Student copy of Onshape Files\nElectronics Electronics aren't that complicated. We use 3 wires to wire the drone receiver to the Arduino Mega and wire up all the motors to the Adafruit Motor shield. Some basic soldering of the header pins onto the Motor Shield is required.\nCode If not already, you should have a way to upload code to an Arduino (Arduino IDE, or Platform IO).\nInstall Arduino IDE\nOtherwise, the code is extremely basic and can be found in the omniwheelcar.ino file.\nMaterials 1.5\u0026quot; [Omni Wheels](38mm (1.5 inches) Double Plastic Omni Wheel with 8 PU Rollers – The Smallest Omni Wheel – 14184 – Oz Robotics) DAGU Robot [Adafruit motor Driver Shield](Motor Stepper Servo Shield 1438 Adafruit Industries | Jameco) Arduino Mega FLYSKY Transmitter \u0026amp; Reciever M3 Lock Nuts M4 Grub Screws [M3 Hobby Park Bushings](Redcat Racing 02101 C-hub Bushings King Pin Bushings 12pcs 02101 609132454745 | eBay) Assorted M3 Bolts Getting Familiarized with MAE Terms Bushing For spinning objects, it is good practice to use a bushing (Which is basically a cheap bearing) instead of simply spinning an object on a bolt. They are typically made of a low friction material like bronze.\nThrough Hole Hole that is meant for a bolt to pass through without interference. I usually use a value = (OD of bolt)\u0026quot; + 1/32\u0026quot;\nTap Hole Hole that is meant for a bolt to thread through it and essentially act like a nut (but without a nut, they're really convenient). It is important to understand that you can only use this with 3D Printing as the plastic will form it's own threads naturally. The pullout force is quite strong but it does not take much torque to strip the threads so you must be carefull of overtightening.\nI use a value of (OD of a bolt)\u0026quot; - 1/64\u0026quot;\nTolerance Anything that we 3D Printing to fit around something \u0026quot;snuggly\u0026quot; must have a little bit of tolerance on it. If we make a hole exactly the size of the motor shaft, it will probably not fit and be WAAAY too tight, therefore we add a little bit extra called Tolerance.\nThere is quite an easy way to achieve this.\nCopy over the geometry of the Motor Shaft (MS). Click on all of the lines and select \u0026quot;Construction\u0026quot; (Or press q on keyboard to toggle) Click on the offset button and offset it by 1/128\u0026quot; This new line will be the Actual geometry that you use to fix the part around the motor shaft. (This value works for my 3D printeres but your results may vary) Gears Gear Types There are different types of gears that we can 3D Print!\nSpur Gear (Left)\nHelical Gear (Middle)\nHerringbone Gear (Right)\nSpur Gear You are probably most used to the gear on the left, that's because they are easy to make and generally the least pain in the ass to use.\nSome disadvantages of them include that you have to constrain the gears in the axial direction. They can slide off each other unless you prevent that from happening with another part. They also make anonying noises because there is not a consistent mating between the two faces that happen.\nHelical Gears These fix the inconsistent mating problem with spur gears but because they are angled, they introduce their own problem of the gears themself wanting to push each other off of the axle. They create their own axial force lol. Cars use helical gears in their gearbox.\nHerringbone Gears They are the best gears because of their coolness. They are basically helical gears mirrored against each other to form a herringbone gears. The axial force formed by the angled teeth cancel each other, which therefore makes no axial load. Additionally, they are self-aligning, they will literally \u0026quot;snap\u0026quot; into place and hold themself from sliding off one another.\nYou probably have never seen these gears in the real world because they are really hard to produce and most of the time you can get away with just a spur gear. 3D printers are like the only machine that can produce herringbone gears so you better take advantage of these cool things.\nPitch diameter The Pitch Diameter tells the mating distance for the gear and is crucial when you're making a gearbox. Like how else would you know the distance to where you should put the other end of the shaft??\nLayout sketch This will be the most important when making the Gearbox plate. This will allow us to let **CAD **find out the positions FOR US for all of our axles. In my layout sketch example:\nThe Pitch Diameters (PD) of both of the gears have a tangent relation to each other. I have drawn the wheel coaxially with it's respective gear to allow me to dimension how much ground clearance I want to have between the bottom of the Motor Pinion gear and the ground (Brown exclamation mark) CAD design Onshape File \u0026amp; Gear Setup Make a copy of Student copy of Onshape Files Open the file and click on the \u0026quot;+\u0026quot; button in the top-right corner to add a custom feature Under \u0026quot;public\u0026quot; search for \u0026quot;Advanced Gear\u0026quot; Add that featurescript to your toolbar Roadmap We will need to create 3 parts specifically in this order:\nMotor Pinion Gear Will have Gear Teeth and a form of coupler to the shaft of the motor Wheel Gear Have Gear Teeth and a form of coupler to the hub of the 1/5\u0026quot; Omni Wheel Needs to have 1/2 the number of Gear Teeth that the Motor Pinion Gear has Gearbox Plate This will hold attach the gear on the wheel to the chassis of the robot and most importantly will ensure a correct amount of spacing between the gears Creating the Motor Pinion Gear Creat new Part Studio Click on Advanced Gear in the top-right corner (The plugin you should've installed) On the window that pops up, change from \u0026quot;Module\u0026quot; to \u0026quot;Diametrical Pitch\u0026quot; Set the Number of gear teeth to 24 Set the Diametrical pitch to 25 Pitch Diameter = Number of Teeth / Diametrical Pitch Diametrical Pitch relates to the density and size of the gear teeth Change the type from \u0026quot;Spur\u0026quot; to Herringbone Set Pressure Angle to 30 ( Just some number that I found that works well for 3D Printing) Set Extrude Depth to 0.25\u0026quot; Hit the check box. Now it's up to you to attach this gear to the motor shaft!\nMake sure to reference the reference motor in the part studio. It is under one of the tabs at the bottom of the screen. Reference the dimensions for the motor shaft and be sure to add tolerance! In order to \u0026quot;secure\u0026quot; the gear pinion to the motor you should use a grub screw! Simply make a tap hole that goes straight into the shaft Creating the Wheel Gear First we need to understand how this is all going to go together.\nThe part that we're going to make must have room for the **bushing **on the end of it and also fit inside of our omni wheel.\nThe idea is that the wheel spins on a long bolt. A lock nut on the end of our wheel-gear assembly keeps everything tight and the entire bolt threads into the gearbox plate that we will make next.\nCreate a new part studio Make a new gear with: The Half the number of teeth as the first gear The SAME DIAMERTICAL PITCH (for some reason the DP changes whenever you change the teeth number, so just be aware of that) The same type of gear as the first one (herringbone, spur, or helical whatever you choose) 0.25\u0026quot; thick 30 degree Pressure Angle Add a coupling method to the Omni Wheel. With enough spacing so that the gear teeth are not in contact with the wheel Through hole for the bushing to fit into Creating the Gearbox Plate This plate attaches the wheel axle to the chassis assembly. We will use the mounting holes on the gearbox as an easy way to attach the plate.\nLayout sketch making Switch to the DAGU DGO2S Motor Gearbox tab. We will make our part directly on the gearbox since we will be referencing items on the gearbox. Create a new sketch on the face of the motor Project the gearbox holes onto the current sketch. Turn the holes into construction lines Rename your sketch to be titled \u0026quot;Layout Sketch\u0026quot; Close out the sketch. Referencing pitch diameters Have you noticed the faint sketch line on the gearbox gears? If you don't notice it you may have the gear feature hidden.\nThe circle is telling you the pitch diameter for your gears. Take note of both of the pitch diameters for your motor pinion and the wheel gear\nGo back to the gearbox tab and edit the layout sketch Add in the construction circles and dimension them so that they represent the pitch diameters of your gears Add in a circle that represents the wheel (1.5\u0026quot; in diameter) Add in another dimenion that ensures the robot with have 1/4\u0026quot; of ground clearance from the lowest hanging object! Exit the sketch and create a new sketch ontop of the layout sketch Construct through holes for the motor gearbox and a tap hole for the wheel gear assembly. Add a clearance hole for the motor pinion gear's coupling method Now construct the gearbox plate around the three holes whilst avoiding the clearance hole! CAD Assembly Now put all the components in an assembly and ensure that there are no weird interferences\nPutting the robot together Now print all the parts and put the robot together!!\nElectrical wiring I bus For this project we will be using a certain protocol called I-Bus in order to remotely control our omni car. It is essentially just UART communication. The great thing about it is that it only requires one signal wire to our Arduino and we are able to get data from 10 different channels on our controller! It is extremely easy to use and gives us very fast data with minimal lag.\nThe I Bus pin on the receiver is circled below. (It took me some time to figure out the right one the first time I was doing this lol)\nWiring Wiring the robot in accordance to this fritzing diagram. I reccomend using double sticky tape to mount the electronics.\n(Triple A batteries should actually be double A batteries as they have more capacity)\nSince these are DC motors, you may need to flip the red and black connections if they are spinning the wrong way.\nPairing the receiver and transmitter If the light on the receiver is not a solid, non-blinking red color, with both the receiver and transmitter turned on, then you will need to pair it.\nSteps for pairing Turn receiver and transmitter off Short out the BIND and VCC pin Turn on the receiver (The red light should be blinking really fast) While holding the \u0026quot;BIND KEY\u0026quot; on the transmitter, turn on the transmitter Transmitter should display something like \u0026quot;RX Binding Ok\u0026quot; and the red light on the receiver shouldn't blink Unshort the BIND and VCC pin Uploading the Code Install the I-Bus communication library Tools -\u0026gt; Manage libraries Search for ibus Install the IBusBM library Uploading the actual code Open the omnicar.ino file and upload that code to the arduino.\n","link":"/mechanical/omni-car-project/","section":"mechanical","title":"Omni Car Project"},{"body":"About the Project We will be creating a pcb slip ring that lights up 2 LED lights with a USB C Connector!\nSlip rings are devices that allow electrical contacts through rotating bodies. ![[slipring.gif|350]]\n![[cadslipring.gif]] Usually you would simply buy a slip ring, so the question remains, why reinvent the slip ring if it already exists?\nMy excuse was that they're expensive. Most especially ones with a through hole in the center :( ![[Pasted image 20220730140802.png]]\nSlip rings are a good way to practice PCB and CAD design. And they kinda cool too!!\nChallenges Kicad We will be making this with KiCAD, a PCB making software. This will be a good intermediate level KiCAD tutorial. Later we will be ordering and assembling our PCB with some SMD components. ![[Pasted image 20220731135313.png]]\nCAD Very minimal CAD in this lesson. There are only 2 parts that will be needed to be designed.\nCode No Code.\nMaterials PCB Making Mouser account JLCPCB Account 5mm breadboard LEDs Solder Paste Mechanical Snap ring pliers Retaining Rings 1/4\u0026quot; Ball Bearing M4 Grub Screws Assorted M3 Bolts The Plan Use USB-C (because it is the future) as a power-input device to power on an LED. This LED will be able to spin indefinitely and still be powered on because it will be on a slip-ring.\nThere will be two boards that we make:\nRing side USB C Female end Current limiting resistor for the LEDs CC Resistors Shell Resistor Exposed copper rings Two mounting holes One large through hole straight through the center ![[Pasted image 20220804221310.png]] Contact side Female dupont pins for the 5mm LEDs Spring contacts that will establish an electrical connection with the other pcb ![[Pasted image 20220804221657.png]] Power through USB C To get 5V from USB C, it is not as simple as just using the VCC lines. Although just using the VCC line for Type A -\u0026gt; USB C cables, this does not work for USB C -\u0026gt; USB C cables or \u0026quot;smart\u0026quot; USB C power supplies.\nUSB C needs a way to acknowledge what type of device is downstream and what voltage to supply at what current. This is where the CC data lines off of the USB C port come in to play. In order to \u0026quot;tell\u0026quot; our power supply what voltage / current we need. Simply connect two 5.1kΩ pulldown resistors to both CC1 and CC2.\nYou'll also notice that there is a SHELL_GND. These are the legs connected to the USB C port. Instead of wiring these directly to GND, they should go through a resistor so that there isn't a ginormous short in the case of a loose power wire. Since we are already using 5.1kΩ resistors, we'll just use a resistor to limit the current.\nHow PCB Design works ![[Pasted image 20220731150317.png]]\nThere are 4 main categories for designing a pcb\nSymbol ![[Pasted image 20220731152202.png|500]] A depiction of a component. Groups of symbols are what you see in a Schematic Footprint ![[Pasted image 20220731152311.png|300]] A depiction of a component for a PCB. They are what you see on a PCB Schematic ![[Pasted image 20220731152433.png|500]] Pictures a collection of symbols and to where they connect to PCB ![[Pasted image 20220731152459.png|500]] Derivated from a schematic Pictures where the components are placed and the traces for each wire [!NOTE] The symbol and the footprint are both associated with an individual component. For instance, a Resistor has a symbol and a footprint associated with it\nSetting up KiCAD Create a new project in KiCAD. You can name it \u0026quot;Baby slip ring\u0026quot;\nImporting Components Because at the time I am writing this, this USB C is in stock and super cheap. Therefore we will be using this one. Unfortunately, not everything that you want to use will already be pre-imported into KiCAD for you. Therefore you must be familiar with importing things (unless you want to make everything yourself). ![[Pasted image 20220804222250.png]]\nDownloading Files To import this you want to scroll down to where it says you can find the Models and click on the link to SnapEDA.\nI like SnapEDA because they are very consistent with providing good quality symbols, footprints, and models. ![[Pasted image 20220804222322.png]] Click on Download symbol and footprint\nSelect KiCAD 6.0\nUnzip the installed folder and place it inside of your project folder\nImporting Footprints Click on Manage footprint libraries under the Preferences menu of KiCAD's main menu ![[Pasted image 20220804225753.png]] Click on the Project specific libraries tab at the top of your screen Click on the plus button in the bottom left hand corner of the window. Name the new entry a good description like \u0026quot;USB C\u0026quot; and then link the correct Path to the library by clicking on the Folder icon ![[Pasted image 20220804225951.png]] Now click on \u0026quot;Migrate libraries\u0026quot; in the bottom right corner of the screen and click \u0026quot;OK\u0026quot; Open the imported footprint in the Footprint Editor to verify that it was successfully imported Importing Schematics Click on Manage symbol libraries under the Preferences menu of KiCAD's main menu Click on the Project specific libraries tab at the top of your screen Hit plus button in bottom left corner Name the new entry (Purple circle) Click on the library logo and select the path to the USB C's .lib file Click Migrate Libraries in the bottom right hand corner of your screen Press OK Now open the file in the symbol editor and verify that it is correct Press E whilst still in the symbol editor to open the properties menu Change the footprint path to be updated and correct by clicking on the little 3 vertical bars menu under \u0026quot;Footprint\u0026quot;![[Pasted image 20220804231359.png]] Under the Datasheet entry, copy/paste in the link to the product page. Using KiCAD Making the Ring Side Rings First we are going to want to make a 2 pin symbol for the Rings.\nOpen up the symbol editor and create a new symbol, simply titled \u0026quot;2 Wire Ring\u0026quot; Draw a simple box with 2 pins. One will be power and the other will be ground Power will have a designator of one and GND will have designator 2.![[Pasted image 20220807170917.png]] Next we should make the footprint for our symbol.\nThe end result should look something like the image below Open up the footprint editor Make a circular pad that is 10.16mm from the origin. The pad must should be 3mm in diameter with no through hole Now right click on the pad and click on \u0026quot;Edit pad as graphical shape\u0026quot; (Ctrl+E) is the shortcut. While in this menu, any shape you draw will be a pad. Make a circular ring with the center point at the origin and the end point on the circle. Change it's thickness to be 3MM Repeat the steps except with a ring that is 15.24mm from the center and having designator of 2. Now click on both of the rings and press \u0026quot;F\u0026quot; on your keyboard. This switches it to the bottom copper layer Readjust the rings so that they are centered on the footprint editor again, if neccessary Ensure that your footprint looks something like this: Now go back to your 2 wire ring symbol and press \u0026quot;E\u0026quot; to edit the properties. Link the footprint to the one that you just made in the last step.\nFinding the 5.1kΩ resistors We will need to find exactly what resistors we are going to buy since we are going to use Power through USB C\nGo to Mouser Navigate to Passive components -\u0026gt; Resistors -\u0026gt; SMD Resistors/Chip Resistors Now use the filters to find the correct resistor that we want. Criterias: Panasonic (since they're a good brand) 5.1kΩ 0402 or 0603 size Hit \u0026quot;Apply Filters\u0026quot; when done Now click on the first part that comes up and that is in stock. Save the link to the product page for later. Finding the 470Ω resistors Follow the directions for the Finding the 5 1kΩ resistors except do it for 470Ω resistors. This is our current limiting resistor for the 5mm LED\nMaking the Schematic Ensure that you have properly installed the symbol and footprint library for our USB C\nOpen the project schematic Drag in the USB C, 2 Wire Ring, and 2 generic Resistor symbol Click on one of the Resistors and press \u0026quot;E\u0026quot; to edit it's properties. Change the value to 5.1k Change the footprint to a SMD Resistor either 0402 or 0603 in size (whatever you chose) Paste in the link to the product page for the Datasheet row Do the same for the other Resistor, except it is the 470Ω variant Copy/Paste in two more 5.1k resistors. Follow the schematic below Making the PCB Press \u0026quot;U\u0026quot; on keyboard to import everything into a PCB. Annotate the board if not already done so.\nMake two cocentric circles on the edge cuts layer to define our board outline. One should be 7.64mm in radius and the other 28.74mm in radius. Ensured that the Rings are cocentric with the board outline. Make USB C Port stick out directly to the right of the center of the circle (orange arrow) . I would reccomend overhanging the USB C port off the edge of the board (red arrow) a bit to ensure that a cable would be able to plug into it. Click on the \u0026quot;Add a footprint\u0026quot; button and find the \u0026quot;MountingHole_3mm\u0026quot;. Place two mounting holes directly above and directly below the center of the slip ring. Each hole should be 22.86mm from the center of the ring. Place the passive components closely around the USB C port. Route all the traces. Press Alt+3 and verify that it looks something like this: Making the Contact Side Create a new project titled \u0026quot;Contact Side\u0026quot;\nSMD Contact Footprint We will be using these spring contacts. The datasheet says that they are rated for sliding and have a height of 5.7mm. Both of which are important for the mechanical aspect of this slip ring.\nNow we will be making the footprint to hold these contacts.\nClick on the above link to the spring contacts and open the datasheet. Create a new footprint within the Contact Side project Follow the \u0026quot;RECOMMENDED PCB LAYOUT\u0026quot; to create two rectangular pads. Press \u0026quot;F\u0026quot; on both of your pads to move them to the bottom copper layer. One of them should be 10.16mm (designator 1) and the other 15.24mm (designator 2) from the center Create a copy of the 2 Wire Ring symbol that you made in the previous step. Except that this one will be for the 2 Spring Contacts.\nNow go back to your newly copied smybol and press \u0026quot;E\u0026quot; to edit the properties. Link the footprint to the one that you just made in the last step.\nMaking the Schematic Create a new schematic Draw in the 2 Spring Contact symbol that you made in the previous step Also import in two generic LEDs. Edit the properties of both of the LEDs Set the footprint of the LEDs to simply just be a 1x2 dupont pin Connect your schematic's traces like so Making the PCB Copy up to step 1 in the previous section's Making the PCB Ensure that the origin of your Spring contacts are cocentric with the board outline. Again, click on the \u0026quot;Add a footprint\u0026quot; button and find the \u0026quot;MountingHole_3mm\u0026quot;. Place two mounting holes directly above and directly below the center of the slip ring. Each hole should be 22.86mm from the center of the ring. Put the LED Duponts 12.7mm to the right of the origin and 10.16mm down Complete the same but mirrored about the y axis Wire up the PCB Add text on the Front Silkscreen layer indicating the positive and negative end of the LED Ordering This is the final step. Make sure that you have made these PCBs correctly and ran the DRC check or else when these pcb's come and they're incorrect it willl be a sad day.\nExporting machining files for JLCPCB With the PCB open, press Plot (Printer icon in top left) Under output directory create a new folder in the project folder named \u0026quot;exports\u0026quot; (this will make exporting easier). Then select that folder you just created as your output directory. Generate drill files (bottom right). Then hit the Generate drill file again on the window that just pops up Close and hit \u0026quot;Plot\u0026quot; Now compress to zip file on the exports folder Now do the same but for the other PCB Ordering from JLC's Website Go to JLCPCB Upload the Ring side zip file to JLCPCB Select the PCB color that you want (Black is usually the best color) Because this has small SMD components that you aren't going to be able to solder by hand, we are going to need to order the stencil. Scroll down to the bottom of the order page and enable the stencil option Repeat the same step except for the Contact side zip file. Know that you do not need to order the stencil as well with the Contact side board. Ordering from Mouser Now we need to order our electrical components from Mouser. As a good rule of thumb, I always order double the quantity of any passive component I may need. Reasoning being that if you fuck up or drop them, they are so small that they are probably gone forever.\nRemember that you can simply click on the link that you assigned to each component under the \u0026quot;Datasheet\u0026quot; column.\nOrder list:\n2x USB Cs 6x 5.1kΩ Resistors 2x 470Ω Resistors 4x SMD Spring Contacts Ordering from Amazon Make sure that you have all the mechanical components that is required to assemble the PCB, since the actual PCB takes about 1-2 weeks to arrive.\n3D Printing Print out the required files for the assembly of the actual slip ring. (Power Input and Output side parts)\nOnshape\nAssembly ","link":"/electrical/baby-slip-ring/documentation/","section":"electrical","title":"PCB Slip Ring Project"},{"body":"Welcome to Envision Hands-On Prototyping, Fabrication and Manufacturing Certificate Mechanical\nElectrical\nEmbedded\nCraft (under construction)\nThe EnVision Hands-on Prototyping, Fabrication and Manufacturing Certificate program is way to formally recognize the advanced work that many students do in the EnVision Arts and Engineering Maker Studio. Aimed towards those students who wish to pursue proficiency beyond what is covered in most classes, the purpose of the certificate program is:\nTo present advanced training on the tools, equipment and resources in the EnVision Maker Studio To formally recognize the work that students do in EnVision To expose students to, and provide them with training on tools they may not encounter or have access to through classroom instruction To incentivize students to continue their engagement with hands-on education beyond the classroom The HOPFAM certification program is entirely project-based. Students may choose one of four focus areas:\nElectrical Design - PCB Design, Schematics, Altium/Eagle/KiCAD, Component Sourcing, Advanced Soldering Mechanical Design - Solidworks/Fusion360, Advanced 3D Printing, Laser Cutting, CNC, Motor/Servo control Embedded Systems - Development Boards, Microcontrollers, Sensor Interaction, HCI, Basic Python/C++ Programming Craft - Woodworking, Joinery, Sewing, Industrial Shop Tools, Inlays, and Advanced Construction Each focus area has 1st and 2nd tier proficiencies. Final projects must represent all 1st tier proficiencies and at least two 2nd tier proficiencies. Students may present their own project ideas for consideration, or choose from existing projects that they may build upon.\nInstruction for each course is self-directed and at any pace. It is generally assumed that each course/project will take around 80 hours to complete and be done over the course of one or two quarters. One-on-one instruction is available for any student upon request for any portion(s) of the course. This website is the primary instructional tool, however, as it provides step-by-step instructions, useful links, files, and more.\n","link":"/","section":"","title":"HOPFAM Home"}]